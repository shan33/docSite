<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Xu's Site Blog</title>
        <link>https://shan33.github.io/docSite/blog</link>
        <description>Xu's Site Blog</description>
        <lastBuildDate>Tue, 28 Dec 2021 07:40:12 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[this相关]]></title>
            <link>https://shan33.github.io/docSite/blog/笔记4</link>
            <guid>笔记4</guid>
            <pubDate>Tue, 28 Dec 2021 07:40:12 GMT</pubDate>
            <description><![CDATA[this]]></description>
            <content:encoded><![CDATA[<blockquote><p>this</p></blockquote><h3>this绑定规则</h3><ol><li>默认绑定(函数直接使用不带任何修饰的函数引用进行调用)</li><li>隐式绑定(调用位置是否有上下文对象)</li></ol><blockquote><p>隐式丢失</p><pre><code class="language-javascript">function foo() {
  console.log(this.a);
}
</code></pre></blockquote><p>var obj = {
a: 2,
foo: foo
};</p><p>var bar = obj.foo;
var a = &#x27;global&#x27;;
bar(); // global</p><pre><code>
3. 显式绑定(apply,bind,call...)
4. new绑定
&gt; 1. 创建一个新的对象
&gt; 2. 对新的对象执行【原型】绑定
&gt; 3. 新对象会绑定到函数调用的this
&gt; 4. 如果函数没有返回其他对象，那么new表达式函数调用会返回这个新的对象

### 判断this
1. 函数是否在new中调用（new绑定）？是的话this绑定的是新创建的对象；
``` javascript
var bar = new foo();
</code></pre><ol start="2"><li>函数是否通过call、apply显式绑定或者硬绑定调用？是的话，this绑定的是指定的对象。</li></ol><pre><code class="language-javascript">var bar = foo.call(obj1);
</code></pre><ol start="3"><li>函数是否在某个上下文对象中调用（隐式绑定）？是的话，this绑定的是上下文对象。</li></ol><pre><code class="language-javascript">var bar = obj1.foo();
</code></pre><ol start="4"><li>都不是，使用默认绑定；严格模式下，绑定undefined，否则绑定到全局对象。</li></ol><pre><code class="language-javascript">var bar = foo();
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[miniprogram-computed源码注释]]></title>
            <link>https://shan33.github.io/docSite/blog/study</link>
            <guid>study</guid>
            <pubDate>Tue, 28 Dec 2021 07:40:12 GMT</pubDate>
            <description><![CDATA[computedBehavior]]></description>
            <content:encoded><![CDATA[<h2>computedBehavior</h2><h3>文件目录</h3><h3>文件目录</h3><p>/node_modules/miniprogram-computed/src</p><blockquote><p>behaviors.ts
data-path.ts
data-tracer.ts
index.ts</p></blockquote><h3>data-tracer</h3><p>3个方法：
<strong>wrapData</strong>、<strong>create</strong>、 <strong>unwrap</strong></p><h3>data-path</h3><p>7个方法：
<strong>throwParsing</strong>、<strong>parseArrIndex</strong>、<strong>parseIndent</strong>、<strong>parseSinglePath</strong>、<strong>parseMultiPaths</strong>、<strong>parseEOF</strong>、<strong>parseMultiDataPaths</strong></p><pre><code class="language-javascript">     /** 
     * 解析除当前确切的监听属性
     * @param path 组件watch属性中的key值
     * @param state 存储当前解析的字符串总长度和解析位置
     */
    const parseMultiPaths = function (path, state) {
      // 跳过\s空白符
      while (WHITE_SPACE_CHAR_REGEXP.test(path[state.index])) {
        state.index++;
      }
      // 调用parseSinglePath方法解析
      const ret = [parseSinglePath(path, state)];
      let splitted = false;
      while (state.index &lt; state.length) {
        const ch = path[state.index];
        if (WHITE_SPACE_CHAR_REGEXP.test(ch)) {
          state.index++;
        } else if (ch === &quot;,&quot;) {
          splitted = true;
          state.index++;
        } else if (splitted) {
          splitted = false;
          ret.push(parseSinglePath(path, state));
        } else {
          throwParsingError(path, state.index);
        }
      }
      return ret;
    };
    
    /** 
     * 解析单个完整属性路径(a, a.b, a.**, a[12]等) 
     */
    const parseSinglePath = function (path, state) {
      // 截取path的一个简单完整属性名称(类似a, _a, _v, $fd)一般父级别
      const paths = [parseIdent(path, state)];
      // 默认deep监听watch为false
      const options = {
        deepCmp: false,
      };
      // 如果还有字符串，继续解析
      // 遇到[]数组(类似target[1], target[name])解析出数字类型
      // 遇到.对象(类似target.name, target.**)
      while (state.index &lt; state.length) {
        const ch = path[state.index];
        if (ch === &quot;[&quot;) {
          state.index++;
          paths.push(parseArrIndex(path, state));
          const nextCh = path[state.index];
          if (nextCh !== &quot;]&quot;) throwParsingError(path, state.index);
          state.index++;
        } else if (ch === &quot;.&quot;) {
          state.index++;
          const ch = path[state.index];
          if (ch === &quot;*&quot;) {
            state.index++;
            const ch = path[state.index];
            // target.** 表示深度监听对象
            if (ch === &quot;*&quot;) {
              state.index++;
              options.deepCmp = true;
              break;
            }
            throwParsingError(path, state.index);
          }
          // 对象继续解析target.name 的name字段
          paths.push(parseIdent(path, state));
        } else {
          break;
        }
      }
      return { path: paths, options };
    };

</code></pre><h3>behavior</h3><p>定义了三个interface.
<strong>BehaviorExtend</strong>、<strong>ObserversItem</strong>、<strong>ComputedWatchInfo</strong>
一个方法：behavior
一个属性：computedWatchDefIdInc(watchDefId为当前watchInfo赋值key并自动累加）</p><p>添加data的proxy代理；
利用observer</p><pre><code class="language-javascript">  const behavior = Behavior({
    lifetimes: {
      created(this) {
        this.setData({ _computedWatchInit: &#x27;created&#x27; });
      },

      attached(this) {
        this.setData({ _computedWatchInit: &#x27;attached&#x27; });
      },
    },

    /**
    * @description 
    * @param defFields 使用该行为的调用对象
    */
    definition(defFields) {
      // 获取watch和computed自定义属性内容
      const { computedDef, watchDef } = defFields;
      // observer数组，存储需要监听的属性
      const observersItems = []; // ObserverItem { fileds: String, observer: () =&gt; {} }

      const computedWatchDefId = computedWatchDefIdInc++;

      // 添加当前组件状态改变监听
      observersItems.push({
        fileds: &#x27;_computedWatchInit&#x27;,
        observer(this) {
          const status = this.data._computedWatchInit;
          // 组件刚被创建的时候，初始化该behavior的watchinfo以及有关的watch属性现有值
          if (status === &#x27;created&#x27;) {
            // 初始化该行为的空白默认计算监听对象
            const computedWatchInfo = {
              computedUpdaters: [],
              computedRelatedPathValues: [],
              watchCurVal: {},
            };
            // 初始化该组件的整体监听对象
            if (!this._computedWatchInfo) {
              this._computedWatchInfo = {};
            }
            // 将该behavior挂载到组件监听对象的特定id中
            this._computedWatchInfo[computedWatchDefId] = computedWatchInfo;
            // 处理watch属性监听，将watch的现有属性值挂到watchCurVal中
            if (watchDef) {
              // 遍历watch属性的key值
              Object.keys(watchDef).forEach((watchPath) =&gt; {
                // 调用dataPath方法获取完整属性key值（具体见dataPath）
                // 特别是&#x27;target.b, target.**, target[1]&#x27;等这类型
                const paths = dataPata.parseMultiDataPaths(watchPath);
                // 记录watch的属性原始值;
                // options主要是.** 这类deepCmp深度监听
                const curVal = paths.map(({ path, options }) =&gt; {
                  const val = dataPath.getDataOnPath(this.data, path);
                  // 深度监听需要深度clone当期那属性保存
                  return options.deepComp ? deepClone(val) : val;
                });
                computedWatchInfo.watchCurVal[watchPath] = curVal;
              })
            } 
          } else if (status === &#x27;attached&#x27;) {
            // 组件进入界面节点树
            // 处理computed字段
            const computedWatchInfo = this._computedWatchInfo[computedWatchDefId];
            if (computedDef) {
              Object.keys(computedDef).forEach((targetField) =&gt; {
                const updateMethod = computedDef[targetField];
                // 计算属性有关的依赖收集
                const relatedPathValuesOnDef = [];

                // 此处调用了data-tracer内部的create,其实就是转发到了tracer的wrapData函数
                // wrapData返回了data的proxy, 并在get方法中将get的属性内容添加到了relatedPath..依赖中
                // updateMethod方法内部为data的proxy
                const val = updateMethod(
                  dataTracer.create(this.data, relatedPathValuesOnDef)
                );
                // 对该计算属性有关的依赖加上依赖属性的值
                const pathValues = relatedPathValuesOnDef.map(({ path }) =&gt; ({
                  path, 
                  value: dataPath.getDataOnPath(this.data, path)
                }));

                // 将计算属性挂载到data中
                // 此处可以做setData动作是因为observer的handlers会强制合并setDatas一起触发
                this.setData({
                  [targetField]: dataTracer.unwrap(val)
                });

                // 将该新增计算属性添加到watchInfo的relatedPathValues
                // { key：计算属性 value：依赖 }  
                computedWatchInfo.computedRelatedPathValues[targetField] = pathValues;

                // setData触发的时候会调用触发
                const updateValueAndRelatedPaths = () =&gt; {
                  const oldPathValues = computedWatchInfo.computedRelatedPathValues[targetField];

                  let needUpdate = false;
                  // 此处获取setData时候计算属性依赖的data是否有变动，有的话需要更新
                  for (let i = 0; i &lt; oldPathValues.length; i++) {
                    const { path, value:oldValue } = oldPathValues[i];
                    const curVal =  dataPath.getDataOnPath(this.data, path);

                    if (oldValue !== curVal) {
                      needUpdate = true;
                      break;
                    }
                  }
                  if (!needUpdate) return false;    
                  
                  // setData时有data更新需要更新计算属性，则重新计算更新该计算属性的值以及依赖属性的值
                  const relatedPathValues = [];
                  const val = updateMethod(
                    dataTracer.create(this.data, relatedPathValues)
                  );
                  
                  this.setData({
                    [targetField]: dataTracer.unwrap(val)
                  })

                  computedWatchInfo.computedRelatedPathValues[targetField] = relatedPathValues;
                  return true;
                }

                computedWatchInfo.computedUpdaters.push(
                  updateValueAndRelatedPaths
                )
                
              })
            }

          }

        }
      });

      // 计算属性会对data.** 进行observer
      if (computedDef) {
        observersItems.push({
          fileds: &#x27;**&#x27;,
          observer(this) {
            if (!this._computedWatchInfo) return;

            const computedWatchInfo = this._computedWatchInfo[computedWatchDefId];

            if (!computedWatchInfo) return;

            let changed = false;
            do {
              // 查看当前计算属性的依赖是否包含更新，并及时更新
              changed = computedWatchInfo.computedUpdaters.some(
                (func) =&gt; func.call(this)
              );
            } while(changed)
          }
        })
      }

      // watch属性会对watch的字段进行observer
      if (watchDef) {
        Object.keys(watchDef).forEach(watchDef =&gt; {
          // 获取属性解析后的data”路径“
          const paths = dataPath.parseMultiDataPaths(watchPath);

          observersItems.push({
            fileds: watchDef,
            observer(this) {
              if (!this._computedWatchInfo) return;
              const computedWatchInfo = this._computedWatchInfo[computedWatchDefId];
              if (!computedWatchInfo) return;

              // 获取老旧属性值， 并更新缓存中的数据
              const oldVal = computedWatchInfo.watchCurVal[watchPath];
              const originalCurValWithOptions = paths.map(({ path, options }) =&gt; {
                const val = dataPath.getDataOnPath(this.data, path);
                return { val, options };
              });
              const curVal = originalCurValWithOptions.map(({ val, options }) =&gt; 
                options.deepComp ? deepClone(val) : val
              );
              computedWatchInfo.watchCurVal[watchPath] = curVal;


              // 对比老旧属性值
              let changed = false;
              for (let i = 0; i &lt; curVal.length; i++) {
                const options = paths[i].options;
                const deepComp = options.deepComp;
                if (deepComp ? !deepEqual(oldVal[i], curVal[i]) : oldVal[i] !== curVal[i]) {
                  changed = true;
                  break;
                }
              }

              if (changed) {
                // 将watch的属性现有值全部传入watch的handler中，并调用
                watchDef[watchPath].apply(this, originalCurValWithOptions.map(({ val }) =&gt; val));
              }
            }
          })
        }) 
      }

      // 监听主要依靠weapp的observer属性
      // 将observerItems里面的监听添加进去组件的observer属性
      if (typeof defFields.observers !== &#x27;object&#x27;) {
        defFields.observers = {};
      }
      if (Array.isArray(defFields.observers)) {
        defFields.observers.push(...observersItems);
      } else {
        observersItems.forEach((item) =&gt; {
          const f = defFields.observers[item.fileds];
          if (!f) {
            defFields.observers[item.fileds] = item.observer;
          } else {
            defFields.observers[item.fileds] = function() {
              item.observer.call(this);
              f.call(this);
            }
          }
        })
      }
    },

  })

</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A1]]></title>
            <link>https://shan33.github.io/docSite/blog/language</link>
            <guid>language</guid>
            <pubDate>Tue, 28 Dec 2021 07:40:12 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[《你不知道的javascript》 笔记1]]></title>
            <link>https://shan33.github.io/docSite/blog/note</link>
            <guid>note</guid>
            <pubDate>Tue, 28 Dec 2021 07:40:11 GMT</pubDate>
            <description><![CDATA[note 图片]]></description>
            <content:encoded><![CDATA[<p><img src="./img/JS_HS.jpg" alt="note 图片"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《你不知道的javascript》 笔记2]]></title>
            <link>https://shan33.github.io/docSite/blog/note2</link>
            <guid>note2</guid>
            <pubDate>Tue, 28 Dec 2021 07:40:11 GMT</pubDate>
            <description><![CDATA[note 图片]]></description>
            <content:encoded><![CDATA[<p><img src="./img/JS%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg" alt="note 图片"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JS严格模式]]></title>
            <link>https://shan33.github.io/docSite/blog/笔记3</link>
            <guid>笔记3</guid>
            <pubDate>Tue, 28 Dec 2021 07:40:11 GMT</pubDate>
            <description><![CDATA[use strict]]></description>
            <content:encoded><![CDATA[<blockquote><p>use strict</p></blockquote><ol><li>LHS找不到变量，不会主动新增；ReferenceError</li><li>this不会默认绑定在window/self等；this=undefined</li></ol>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[setCookie]]></title>
            <link>https://shan33.github.io/docSite/blog/cookie</link>
            <guid>cookie</guid>
            <pubDate>Tue, 28 Dec 2021 07:40:11 GMT</pubDate>
            <description><![CDATA[debug setCookie测试环境为空了...]]></description>
            <content:encoded><![CDATA[<blockquote><p>debug setCookie测试环境为空了...</p></blockquote><p>晕了晕了</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[finally...]]></title>
            <link>https://shan33.github.io/docSite/blog/life</link>
            <guid>life</guid>
            <pubDate>Thu, 16 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[终于搞定了github page; 配置完成了github actions~]]></description>
            <content:encoded><![CDATA[<p>终于搞定了github page; 配置完成了github actions<del>~
拥有了自己的一片新天地~
aha ~</del></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[随想]]></title>
            <link>https://shan33.github.io/docSite/blog/welcome</link>
            <guid>welcome</guid>
            <pubDate>Mon, 29 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[无聊记事： 今天杭州又下雨了~]]></description>
            <content:encoded><![CDATA[<p>无聊记事： 今天杭州又下雨了~</p>]]></content:encoded>
        </item>
    </channel>
</rss>